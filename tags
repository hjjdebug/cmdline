!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AR	Makefile	/^AR            = ar cqs$/;"	m
CAST	cast.h	/^namespace CAST$/;"	n
CC	Makefile	/^CC            = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS        = -pipe -O2 -Wall -Wextra -D_REENTRANT -fPIC $(DEFINES)$/;"	m
CHK_DIR_EXISTS	Makefile	/^CHK_DIR_EXISTS= test -d$/;"	m
COMPRESS	Makefile	/^COMPRESS      = gzip -9f$/;"	m
COPY	Makefile	/^COPY          = cp -f$/;"	m
COPY_DIR	Makefile	/^COPY_DIR      = cp -f -R$/;"	m
COPY_FILE	Makefile	/^COPY_FILE     = cp -f$/;"	m
CXX	Makefile	/^CXX           = g++$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS      = -pipe -O2 -Wall -Wextra -D_REENTRANT -fPIC $(DEFINES)$/;"	m
DEFINES	Makefile	/^DEFINES       = -DQT_NO_DEBUG -DQT_GUI_LIB -DQT_CORE_LIB$/;"	m
DEL_DIR	Makefile	/^DEL_DIR       = rmdir$/;"	m
DEL_FILE	Makefile	/^DEL_FILE      = rm -f$/;"	m
DESTDIR	Makefile	/^DESTDIR       = $/;"	m
DIST	Makefile	/^DIST          = \/opt\/Qt5.14.0\/5.14.0\/gcc_64\/mkspecs\/features\/spec_pre.prf \\$/;"	m
DISTDIR	Makefile	/^DISTDIR = \/home\/hjj\/test\/cmdline\/.tmp\/cmdline1.0.0$/;"	m
DISTNAME	Makefile	/^DISTNAME      = cmdline1.0.0$/;"	m
EQ	Makefile	/^EQ            = =$/;"	m
INCPATH	Makefile	/^INCPATH       = -I. -I. -I\/opt\/Qt5.14.0\/5.14.0\/gcc_64\/include -I\/opt\/Qt5.14.0\/5.14.0\/gcc_64\/include\/QtGui -I\/opt\/Qt5.14.0\/5.14.0\/gcc_64\/include\/QtCore -I. -isystem \/usr\/include\/libdrm -I\/opt\/Qt5.14.0\/5.14.0\/gcc_64\/mkspecs\/linux-g++$/;"	m
INSTALL_DIR	Makefile	/^INSTALL_DIR   = cp -f -R$/;"	m
INSTALL_FILE	Makefile	/^INSTALL_FILE  = install -m 644 -p$/;"	m
INSTALL_PROGRAM	Makefile	/^INSTALL_PROGRAM = install -m 755 -p$/;"	m
LFLAGS	Makefile	/^LFLAGS        = -Wl,-O1 -Wl,-rpath,\/opt\/Qt5.14.0\/5.14.0\/gcc_64\/lib$/;"	m
LIBS	Makefile	/^LIBS          = $(SUBLIBS) \/opt\/Qt5.14.0\/5.14.0\/gcc_64\/lib\/libQt5Gui.so \/opt\/Qt5.14.0\/5.14.0\/gcc_64\/lib\/libQt5Core.so -lGL -lpthread   $/;"	m
LINK	Makefile	/^LINK          = g++$/;"	m
MAKEFILE	Makefile	/^MAKEFILE      = Makefile$/;"	m
MKDIR	Makefile	/^MKDIR         = mkdir -p$/;"	m
MOVE	Makefile	/^MOVE          = mv -f$/;"	m
OBJECTS	Makefile	/^OBJECTS       = main.o$/;"	m
OBJECTS_DIR	Makefile	/^OBJECTS_DIR   = .\/$/;"	m
QINSTALL	Makefile	/^QINSTALL      = \/opt\/bin\/qmake -install qinstall$/;"	m
QINSTALL_PROGRAM	Makefile	/^QINSTALL_PROGRAM = \/opt\/bin\/qmake -install qinstall -exe$/;"	m
QMAKE	Makefile	/^QMAKE         = \/opt\/bin\/qmake$/;"	m
QMAKE_TARGET	Makefile	/^QMAKE_TARGET  = cmdline$/;"	m
RANLIB	Makefile	/^RANLIB        = $/;"	m
SED	Makefile	/^SED           = sed$/;"	m
SOURCES	Makefile	/^SOURCES       = main.cpp $/;"	m
STRIP	Makefile	/^STRIP         = strip$/;"	m
SYMLINK	Makefile	/^SYMLINK       = ln -f -s$/;"	m
TAR	Makefile	/^TAR           = tar -cf$/;"	m
TARGET	Makefile	/^TARGET        = cmdline$/;"	m
_CAST_H	cast.h	2;"	d
_MY_EXCEPTION_H	myexception.h	2;"	d
_OPTION_H	option.h	2;"	d
_PARSER_H	parser.h	2;"	d
actual	option.h	/^		T actual;$/;"	m	class:option_with_value
add	parser.h	/^			void add(const std::string &name,$/;"	f	class:parser
add	parser.h	/^		void add(const std::string &name,$/;"	f	class:parser
add	reader.h	/^	void add(const T &v){ alt.push_back(v); } \/\/定义add 操作函数，为向vector中push_back$/;"	f	struct:oneof_reader
alt	reader.h	/^	std::vector<T> alt;$/;"	m	struct:oneof_reader
cast	cast.h	/^				static Target cast(const Source &arg){$/;"	f	class:CAST::lexical_cast_t
cast	cast.h	/^				static Target cast(const std::string &arg){$/;"	f	class:CAST::lexical_cast_t
cast	cast.h	/^				static std::string cast(const Source &arg){$/;"	f	class:CAST::lexical_cast_t
check	parser.h	/^		void check(int argc, bool ok) \/\/检查是否需要打印帮助信息$/;"	f	class:parser
cmdline_error	myexception.h	/^		cmdline_error(const std::string &msg): msg(msg){}$/;"	f	class:cmdline_error
cmdline_error	myexception.h	/^class cmdline_error : public std::exception { \/\/定义cmdline_error 类$/;"	c
def	option.h	/^		T def;$/;"	m	class:option_with_value
default_reader	reader.h	/^struct default_reader$/;"	s
default_value	cast.h	/^		std::string default_value(T def)$/;"	f	namespace:CAST
demangle	cast.h	/^	static inline std::string demangle(const std::string &name) \/\/解除撕裂,c++的类型名是mangle 过的, 人类可读性差,demangle后，变为可读字符.$/;"	f	namespace:CAST
desc	option.h	/^		std::string desc;$/;"	m	class:option_with_value
desc	option.h	/^		std::string desc;$/;"	m	class:option_without_value
description	option.h	/^		const std::string &description() const {$/;"	f	class:option_with_value
description	option.h	/^		const std::string &description() const {$/;"	f	class:option_without_value
error	parser.h	/^		std::string error() const$/;"	f	class:parser
error_full	parser.h	/^		std::string error_full() const$/;"	f	class:parser
errors	parser.h	/^		std::vector<std::string> errors;$/;"	m	class:parser
exist	parser.h	/^		bool exist(const std::string &name) const {$/;"	f	class:parser
footer	parser.h	/^		void footer(const std::string &f)$/;"	f	class:parser
ftr	parser.h	/^		std::string ftr;	\/\/footer$/;"	m	class:parser
full_description	option.h	/^		std::string full_description(const std::string &desc){$/;"	f	class:option_with_value
g_pmtpid	main.cpp	/^string g_pmtpid = "";$/;"	v
g_serviceid	main.cpp	/^string g_serviceid = "";$/;"	v
g_tsid	main.cpp	/^string g_tsid = "";$/;"	v
g_videopid	main.cpp	/^string g_videopid = "";$/;"	v
get	option.h	/^		const T &get() const {$/;"	f	class:option_with_value
get	parser.h	/^			const T &get(const std::string &name) const {$/;"	f	class:parser
has	option.h	/^		bool has;$/;"	m	class:option_with_value
has	option.h	/^		bool has;$/;"	m	class:option_without_value
has_set	option.h	/^		bool has_set() const {$/;"	f	class:option_without_value
has_set	option.h	/^		bool has_set() const{$/;"	f	class:option_with_value
has_value	option.h	/^		bool has_value() const { return false; }$/;"	f	class:option_without_value
has_value	option.h	/^		bool has_value() const { return true; }$/;"	f	class:option_with_value
high	reader.h	/^	T low, high;$/;"	m	struct:range_reader
is_same	cast.h	/^		struct is_same {	\/\/is_same 是一个结构$/;"	s	namespace:CAST
is_same	cast.h	/^		struct is_same<T, T>{$/;"	s	namespace:CAST
lexical_cast	cast.h	/^		Target lexical_cast(const Source &arg) \/\/类型转换$/;"	f	namespace:CAST
lexical_cast_t	cast.h	/^		class lexical_cast_t<Target, Source, true>{ \/\/Source 与Target 类型一致$/;"	c	namespace:CAST
lexical_cast_t	cast.h	/^		class lexical_cast_t<Target, std::string, false>{ \/\/string 转 Target$/;"	c	namespace:CAST
lexical_cast_t	cast.h	/^		class lexical_cast_t<std::string, Source, false>{ \/\/Source 转 string$/;"	c	namespace:CAST
lexical_cast_t	cast.h	/^		class lexical_cast_t{$/;"	c	namespace:CAST
low	reader.h	/^	T low, high;$/;"	m	struct:range_reader
main	main.cpp	/^int main(int argc, char **argv) $/;"	f
msg	myexception.h	/^		std::string msg;$/;"	m	class:cmdline_error
must	option.h	/^		bool must() const{ \/\/ 无值,must 为false$/;"	f	class:option_without_value
must	option.h	/^		bool must() const{$/;"	f	class:option_with_value
nam	option.h	/^		std::string nam;$/;"	m	class:option_with_value
nam	option.h	/^		std::string nam;$/;"	m	class:option_without_value
name	option.h	/^		const std::string &name() const{$/;"	f	class:option_with_value
name	option.h	/^		const std::string &name() const{$/;"	f	class:option_without_value
need	option.h	/^		bool need;$/;"	m	class:option_with_value
oneof	reader.h	/^oneof_reader<T> oneof(T a1) \/\/定义oneof 函数，定义oneof_read<T>对象， 向其加入一个变量a1$/;"	f
oneof	reader.h	/^oneof_reader<T> oneof(T a1, T a2) \/\/定义oneof 函数，定义oneof_read<T>对象， 向其加入n个变量a1, 2,3,4,5,6,7,8,9,10个变量$/;"	f
oneof	reader.h	/^oneof_reader<T> oneof(T a1, T a2, T a3)$/;"	f
oneof	reader.h	/^oneof_reader<T> oneof(T a1, T a2, T a3, T a4)$/;"	f
oneof	reader.h	/^oneof_reader<T> oneof(T a1, T a2, T a3, T a4, T a5)$/;"	f
oneof	reader.h	/^oneof_reader<T> oneof(T a1, T a2, T a3, T a4, T a5, T a6)$/;"	f
oneof	reader.h	/^oneof_reader<T> oneof(T a1, T a2, T a3, T a4, T a5, T a6, T a7)$/;"	f
oneof	reader.h	/^oneof_reader<T> oneof(T a1, T a2, T a3, T a4, T a5, T a6, T a7, T a8)$/;"	f
oneof	reader.h	/^oneof_reader<T> oneof(T a1, T a2, T a3, T a4, T a5, T a6, T a7, T a8, T a9)$/;"	f
oneof	reader.h	/^oneof_reader<T> oneof(T a1, T a2, T a3, T a4, T a5, T a6, T a7, T a8, T a9, T a10)$/;"	f
oneof_reader	reader.h	/^struct oneof_reader{	\/\/定义oneof_reader 结构，$/;"	s
operator ()	reader.h	/^	T operator()(const std::string &s) const {$/;"	f	struct:range_reader
operator ()	reader.h	/^	T operator()(const std::string &s){ \/\/定义其运算符()为将参数s转换为T,并在vector中查找，未找到抛出异常,找到返回T 的值$/;"	f	struct:oneof_reader
operator ()	reader.h	/^	T operator()(const std::string &str){ \/\/其运算符()的意义为把string转换为T类型$/;"	f	struct:default_reader
option_base	option.h	/^class option_base$/;"	c
option_with_value	option.h	/^		option_with_value(const std::string &name,$/;"	f	class:option_with_value
option_with_value	option.h	/^class option_with_value : public option_base 	\/\/带值的选项, 模板类$/;"	c
option_with_value_with_reader	option.h	/^		option_with_value_with_reader(const std::string &name,$/;"	f	class:option_with_value_with_reader
option_with_value_with_reader	option.h	/^class option_with_value_with_reader : public option_with_value<T> $/;"	c
option_without_value	option.h	/^		option_without_value(const std::string &name,$/;"	f	class:option_without_value
option_without_value	option.h	/^class option_without_value : public option_base  \/\/无value 的选项$/;"	c
options	parser.h	/^		std::map<std::string, option_base*> options; \/\/使用options_base* 就够了！$/;"	m	class:parser
ordered	parser.h	/^		std::vector<option_base*> ordered;$/;"	m	class:parser
others	parser.h	/^		std::vector<std::string> others;$/;"	m	class:parser
parse	parser.h	/^		bool parse(const std::string &arg)$/;"	f	class:parser
parse	parser.h	/^		bool parse(const std::vector<std::string> &args)$/;"	f	class:parser
parse	parser.h	/^		bool parse(int argc, const char * const argv[]) \/\/选项分析3$/;"	f	class:parser
parse_check	parser.h	/^		void parse_check(const std::string &arg){$/;"	f	class:parser
parse_check	parser.h	/^		void parse_check(const std::vector<std::string> &args){$/;"	f	class:parser
parse_check	parser.h	/^		void parse_check(int argc, char *argv[]){$/;"	f	class:parser
parser	parser.h	/^		parser(){ }$/;"	f	class:parser
parser	parser.h	/^class parser$/;"	c
prog_name	parser.h	/^		std::string prog_name;$/;"	m	class:parser
range	reader.h	/^range_reader<T> range(const T &low, const T &high) \/\/定义一个函数range,返回range_reader 类对象$/;"	f
range_reader	reader.h	/^	range_reader(const T &low, const T &high): low(low), high(high) {} \/\/range_reader 的构造函数$/;"	f	struct:range_reader
range_reader	reader.h	/^struct range_reader$/;"	s
read	option.h	/^		T read(const std::string &s){$/;"	f	class:option_with_value_with_reader
readable_typename	cast.h	/^		inline std::string readable_typename<std::string>() \/\/偏特化$/;"	f	namespace:CAST
readable_typename	cast.h	/^		std::string readable_typename()$/;"	f	namespace:CAST
reader	option.h	/^		F reader;$/;"	m	class:option_with_value_with_reader
rest	parser.h	/^		const std::vector<std::string> &rest() const $/;"	f	class:parser
set	option.h	/^		bool set(){	\/\/ 无value, 设置返回真,并置位has 为true(表示已经设置过）$/;"	f	class:option_without_value
set	option.h	/^		bool set(){$/;"	f	class:option_with_value
set	option.h	/^		bool set(const std::string &){ \/\/设置字符串就不必了$/;"	f	class:option_without_value
set	option.h	/^		bool set(const std::string &value){ \/\/把数值用参数传进来$/;"	f	class:option_with_value
set_option	parser.h	/^		void set_option(const std::string &name) \/\/设置选项，无值$/;"	f	class:parser
set_option	parser.h	/^		void set_option(const std::string &name, const std::string &value) \/\/设置选项，带值$/;"	f	class:parser
set_program_name	parser.h	/^		void set_program_name(const std::string &name)$/;"	f	class:parser
short_description	option.h	/^		std::string short_description() const{ \/\/short_description 给nam$/;"	f	class:option_without_value
short_description	option.h	/^		std::string short_description() const{$/;"	f	class:option_with_value
short_name	option.h	/^		char short_name() const{$/;"	f	class:option_with_value
short_name	option.h	/^		char short_name() const{$/;"	f	class:option_without_value
snam	option.h	/^		char snam;$/;"	m	class:option_with_value
snam	option.h	/^		char snam;$/;"	m	class:option_without_value
usage	parser.h	/^		std::string usage() const  \/\/打印帮助信息$/;"	f	class:parser
valid	option.h	/^		bool valid() const{$/;"	f	class:option_with_value
valid	option.h	/^		bool valid() const{$/;"	f	class:option_without_value
value	cast.h	/^			static const bool value = false;	\/\/存一个静态常布尔值false$/;"	m	struct:CAST::is_same
value	cast.h	/^			static const bool value = true; \/\/两种类型一致,存true$/;"	m	struct:CAST::is_same
what	myexception.h	/^		const char *what() const throw() { return msg.c_str(); }$/;"	f	class:cmdline_error
~cmdline_error	myexception.h	/^		~cmdline_error() throw() {}$/;"	f	class:cmdline_error
~option_base	option.h	/^		virtual ~option_base(){}$/;"	f	class:option_base
~option_with_value	option.h	/^		~option_with_value(){}$/;"	f	class:option_with_value
~option_without_value	option.h	/^		~option_without_value(){}$/;"	f	class:option_without_value
~parser	parser.h	/^		~parser()$/;"	f	class:parser
